---
slug: bundler
title: Production Build
tags:
  - webpack4.0
categories:
  - Front-end
  - webpack4.0 Learning Summary
references:
  - name: >-
      From Basics to Practice, Hand-in-Hand to Master the New Version of
      Webpack4.0
    url: 'https://coding.imooc.com/class/chapter/316.html#Anchor'
  - name: webpack official website
    url: 'https://webpack.js.org/'
date: 2020-05-25T14:43:46.000Z
updated: 2020-05-30T17:20:00.000Z
sidebar_position: 5
summary: >-
  Tree Shaking can achieve on-demand packaging of JS files, which is only
  effective in the production environment.

  Create different configuration files for production and development
  environments to facilitate the management and expansion.

  Use code splitting to implement lazy loading (using magic comments) and
  preloading.

  Use status.json to analyze the packaging process.

  Generate css files separately to reduce the size of main.js.

  Set the hash value for the output file to solve the cache problem.
ai_translation: true
---

## Tree Shaking On-demand Packaging Files

Tree Shaking is used to remove unused code when packaging, which can optimize the size of the packaged product.

<Tabs>
  <TabItem value="index" label="index.js">

```js
import { used } from './moment';

used();
```

  </TabItem>
  <TabItem value="moment" label="moment.js">

```js
export function used() {
  console.log('used function');
}

export function notUsed() {
  console.log('notUsed funtion');
}
```

  </TabItem>
</Tabs>

In the example above, we only use `used` in moment, but after packaging, `notUsed` is also packaged into the main.js file

![image-20200525151309388](https://raw.githubusercontent.com/3Alan/images/master/img/image-20200525151309388.png)

Tree Shaking can help us solve this problem.

```js title="Enable mode"
optimization: {
  usedExports: true,
}

// production mode will be automatically configured, optional
```

:::warning

- After opening, for *side effect files*, you need to declare them separately to avoid being deleted
- Only supports ES Module syntax (import), not CommonJs
- Tree Shaking is enabled by default only in production mode.

:::

```json title="package.json"
"sideEffects": [
  "**/*.css",
  "**/*.scss",
  "./esnext/index.js",
  "./esnext/configure.js"
],
```

It means that these files are not tree shaken
For example
`import './common.css';`
Although we didn't use some of the `common.css`, it plays the role of style. If it is not set in sideEffect, webpack will not package it into the product.

Or `"sideEffects": false`

## Development and Production Environment Configuration Files

Since the development environment needs to debug the code, plugins such as `devServer` will be introduced, so this part of the plugin is not needed in the production environment. We can set different configuration files for the development and production environments.

First, install the plugin `webpack-merge` to splice the common configuration

```
npm i webpack-merge -D
```

The directory is as follows:

```
webpacktest
 ├── package.json
 ├── src
 │   ├── index.html
 │   ├── index.js
 │   └── moment.js
 ├── webpack.common.js
 ├── webpack.dev.js
 └── webpack.prod.js
```

<Tabs>
  <TabItem value="webpack.common.js" label="webpack.common.js">

```js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

module.exports = {
  mode: 'development', // Defaults to production
  entry: {
    main: './src/index.js' // Package entry file
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/, // Do not process js files under node_modules
        loader: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  output: {
    // Output file configuration
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist')
  },
  optimization: {
    usedExports: true
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html'
    }),
    new CleanWebpackPlugin()
  ]
};
```

  </TabItem>
  <TabItem value="webpack.dev.js" label="webpack.dev.js">

```js
const merge = require('webpack-merge');
const commonConfig = require('./webpack.common.js');

const devConfig = {
  mode: 'development', // Defaults to production
  devtool: 'cheap-module-eval-source-map',
  devServer: {
    contentBase: './dist',
    open: true, // Automatically open the browser
    port: 3001, // Server port number
    hot: true // Enable HRM
  }
};

module.exports = merge(commonConfig, devConfig);
```

  </TabItem>
  <TabItem value="webpack.prod.js" label="webpack.prod.js">

```js
const merge = require('webpack-merge');
const commonConfig = require('./webpack.common.js');

const prodConfig = {
  mode: 'development', // Defaults to production
  devtool: 'cheap-module-source-map'
};

module.exports = merge(commonConfig, prodConfig);
```

  </TabItem>
  <TabItem value="npm script" label="npm script">

```json
"scripts": {
    "dev": "webpack-dev-server --config webpack.dev.js",
    "build": "webpack --config webpack.prod.js"
},
```

  </TabItem>
</Tabs>

After the configuration is complete, use `npm run dev` for packaging in the development environment and `npm run build` for packaging in the production environment.

## Code Splitting

Code splitting is beneficial for performance optimization. What is code splitting:

There is such a scenario that I use some public code library/tool library (lodash) in `index.js`, and the code in `index.js` depends on some tools in lodash. When we package, lodash is also packaged into the `main.js` file, and once the business code in `index.js` changes, lodash must be repackaged and loaded together, but we generally do not change this type of tool library. So we can use code splitting to split the business code and lodash, so that the next time we modify the business code, we don't need to reload the content of lodash.

First install lodash

```
npm i lodash -S
```

Here, in order to facilitate viewing the content of the packaged file, we add an npm script `"start": "webpack --config webpack.dev.js"` (because devServer will not generate packaged content)

```js title="index.js"
import _ from 'lodash';

console.log(_.compact([0, 1, false, 2, '', 3]));
```

`npm run start` packaging, it is found that the packaged main.js file contains lodash content.

So how to achieve code splitting, just configure the webpack.common.js file

```js
optimization: {
  splitChunks: {
    chunks: 'all';
  }
}
```

Pack again, and you will find that there is an extra `vendor~main.js` in the packaged file, and webpack automatically packs the lodash content into it, and there is no lodash content in the main.js file.

```
dist
 ├── index.html
 ├── main.js
 └── vendors~main.js
```

The above introduces synchronous code splitting. Let's take a look at the asynchronous code splitting `index.js`, which can achieve **lazy loading**.

```js
async function createElement() {
  const { default: _ } = await import(/* webpackChunkName: "lodash" */ 'lodash');
  const element = document.createElement('div');
  element.innerHTML = _.compact([0, 1, false, 2, '', 3]);
  return element;
}

document.addEventListener('click', () => {
  createElement().then(element => {
    document.body.appendChild(element);
