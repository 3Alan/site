---
slug: mitt
title: Mitt Source Code Animation Analysis
tags:
  - Source Code Reading
keywords:
  - Mitt
  - Source Code Analysis
  - Event emitter
  - Event Dispatcher
  - Publish-Subscribe Pattern
  - Observer Pattern
date: 2023-02-12T00:00:00.000Z
description: >-
  Implement a simple event dispatcher using the publish-subscribe pattern. This
  article will explain Mitt's source code and its implementation principles in
  detail with animations, allowing you to quickly understand Mitt's usage and
  advantages.
references:
  - name: Map and Set
    url: 'https://zh.javascript.info/map-set'
  - name: Not a Number Blog
    url: 'https://www.nan.fyi/'
  - name: mitt Repository
    url: 'https://github.com/developit/mitt'
summary: >-
  Mitt is a very simple publish-subscribe library that uses Map to store events
  and handlers. When `mitt.on` is called, it adds the event and handler to the
  Map. When `mitt.off` is called, it removes the event and handler from the Map.
  When `mitt.emit` is called, it triggers all handlers subscribed to that event.
  Mitt also provides the `mitt.once` method, which is used to trigger a
  subscribed handler only once.


  The publish-subscribe pattern is a design pattern that allows objects to
  communicate with each other without knowing each other's specific
  implementation. The observer pattern is a special case of the
  publish-subscribe pattern, in which an observer object subscribes to only one
  observable object.
ai_translation: true
---

import {
  PubSubBaseExample,
  PubSubAllExample,
  PubSubScreenExample,
  ObserverExample
} from '../../src/contentExamples/pubSub';

Mitt's source code is very simple, with less than 100 lines of code. This article will explain it with animations.

:::tip
Please use a PC to read this article for the best reading experience.
:::

## Prerequisites

- [Map](https://zh.javascript.info/map-set)
  - `map.set(key, value)`
  - `map.get(key)`
  - `map.clear()`
- Publish-subscribe pattern

## Specific Coding

The code is very simple, mainly maintaining an `all` Map, and performing add (`mitt.on`), delete (`mitt.off`), modify (`mitt.on`), and query (`mitt.emit`) operations on it.

```js
function mitt() {
  const all = new Map();

  const on = (type, handler) => {
    const handlers = all.get(type);
    if (handlers) {
      handlers.push(handler);
    } else {
      all.set(type, [handler]);
    }
  };

  const off = (type, handler) => {
    const handlers = all.get(type);
    if (!handlers) {
      return;
    }

    if (handler) {
      const handlerIndex = handlers.indexOf(handler);
      const hasHandler = handlerIndex !== -1;
      if (hasHandler) {
        handlers.splice(handlerIndex, 1);
      }
    } else {
      all.set(type, []);
    }
  };

  const emit = (type, params) => {
    let handlers = all.get(type);
    if (handlers) {
      handlers.slice().map(handler => handler(params));
    }

    // If no event listener is found, check if all events are listened to *
    handlers = all.get('*');
    if (handlers) {
      handlers.slice().map(handler => handler(params));
    }
  };

  const once = (type, handler) => {
    const onceFn = params => {
      handler(params);
      off(type, onceFn);
    };

    on(type, onceFn);
  };

  // Use Map's own clear function to clear all subscriptions

  return {
    all,
    on,
    once,
    off,
    emit
  };
}
```

Combine the code above and watch the animation.

<PubSubBaseExample eventBusTitle="EventBus(all)" />

### `on('*')`

`mitt.on` has a special case, which is to listen to all events. This only needs to be handled specially in the `emit` function. When no related subscriber is found, execute all functions under `all.get('*')`.

<PubSubAllExample />

## Extension

The code uses the publish-subscribe pattern. The following scenarios will briefly introduce the publish-subscribe pattern and the observer pattern, which is very similar to it.

### Observer Pattern

One day, Xiaoming went to the convenience store at the door to buy yogurt as usual, but the owner was out of business, so he dialed the phone on the door, and the owner said that he would call him when the store opened. So the owner saved Xiaoming's phone number in his notebook. Two days later, Xiaoming received a call from the owner saying that the store was open, so he immediately went to the convenience store to buy his favorite yogurt.

In the scenario above, the observer (Observer) is Xiaoming, the observable (Subject) is the owner, and the phone number recorded in the owner's notebook is the observer list (ObserverList).

<ObserverExample />

### Publish-Subscribe Pattern

On the way home, Xiaoming saw an advertisement for a second-hand trading software at the door, with a QR code for downloading the APP. Xiaoming happened to be short of a screen because he was working from home recently, so he downloaded the APP with a try. After opening the APP, users only need to post their needs or second-hand items on the APP, and the platform will help you find buyers or sellers and ensure the privacy of both parties. So Xiaoming uploaded his needs on the APP and waited for the platform to notify him.

Xiaohong happened to have an idle screen, so she posted a sales request on the APP.

After Xiaohong posted the request, the system matched someone who needed a screen and sent a notification to the corresponding person, so Xiaoming received the notification.

In the scenario above, Xiaoming, as a subscriber (sub), subscribes to the demand for screens, while Xiaohong, as a publisher (pub), publishes the demand for screens. The APP acts as an event bus (eventBus) to handle these requests. For Xiaoming and Xiaohong, they do not know each other's relevant information. All communication is completed through the APP as an intermediary, decoupling the two.

<PubSubScreenExample />
