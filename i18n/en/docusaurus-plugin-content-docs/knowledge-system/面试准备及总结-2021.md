---
slug: interview-summary-2021
title: Front-end Interview Questions Summary - 2021
date: 2021-02-24T23:14:08.000Z
tags:
  - Front-end Interview Summary
displayed_sidebar: interviewSidebar
summary: >-
  Memory management includes modularization, Promise, async/await, interview
  questions, basic points, different types of comparisons, object to primitive
  type, primitive type methods, structure assignment, Symbol.iterator, WeakMap
  and Map differences, Map and Set, Set and WeakSet, garbage collection, ES6,
  file upload, ESM and CJS, scrolling Tab, error capturing, cookies, differences
  between interface and type, React, vdom, diff dom, synthetic events, class and
  hooks, useEffect and useLayoutEffect, React Router.
ai_translation: true
---

## Memory Management

https://juejin.cn/post/6844903869525262349

## Modularization (type = "module")

https://zh.javascript.info/modules-intro

- Always use strict mode
- Each module has a scope
- If imported multiple times, it will only be imported once and shared
- `this` is `undefined`
- It will not run until the HTML document is ready (can be solved with the async attribute)
- Use `nomodule` to solve compatibility issues
- Each file can only have one default export
- Dynamic import uses `import()`, which returns a `promise`

## Promise

https://zh.javascript.info/promise-basics

Promise chaining

```js
let p = new Promise((resolve, reject) => {
  setTimeout(() => resolve(1), 1000);
});
p.then(res => {
  console.log(res); //1
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(res * 2), 1000);
  });
}).then(res => {
  console.log(res); //2
});
```

The result returned in then will be passed to the next then

- `Promise.all([...promises...])`

  - Waits for all promises to be settled before settling, and the result is an array of results from all `promise` `resolve`s, and the order of the array is independent of the order in which all promises are completed.
  - If one promise is rejected, the entire promise will be rejected **immediately**, with the error of the rejected promise, and the other promises that are executing will be ignored (but not canceled).

- `Promise.allSettled([...promises...])` (ES2020 new)

  - Solves the problem in the second feature of Promise.all([...promises...]). Promise.allSettled will wait for all promises to be settled, regardless of the outcome.
  - Returns an array with data of the type `{status:"fulfilled"/"rejected", value:result/error}`

- `Promise.race([...promises...])`

  - Returns the first settled promise

- `Promise.resolve(value)`
  Equivalent to `let promise = new Promise(resolve => resolve(value));`

- `Promise.reject(reject)`

### async/await

- Functions wrapped in async always return a promise

## Interview Questions

### Swap the values of 2 variables without referencing a third variable

For example, to achieve the following effect

```
let a = 1;
let b = 2;

Eventually
a = 2
b = 1
```

Method one, XOR
a = a ^ b
b = a ^ b
a = a ^ b

```
Specific reasoning process
a = 0010
b = 0001
    ||||
    vvvv
a = 0011 = 3
b = 0001
    ||||
    vvvv
b = 0010 = 2
a = 0011
    ||||
    vvvv
a = 0001 = 1
```

Method two, ES6 destructuring

```
[a, b] = [b, a]
```

## JavaScript Basics

- The `+` operator, as long as one of the operands is a string, the other operand will also be converted to a string.

### Optional chaining `?.`

The preceding part is `undefined` or `null`, it will stop the operation and return, and there is a short-circuit effect

**Can be used to read and delete variables, but cannot be used to write (assign)**

```js
let user = {}; // user has no address property

alert(user?.address?.street); // undefined (no error)
```

```js
let user = null; // Suppose we can't authorize this user

alert(user?.address); // undefined
alert(user?.address.street); // undefined
alert(user.address?.street); // Error
```

Can also be used to call functions

```js
let userAdmin = {
  admin() {
    alert('I am admin');
  }
};

let userGuest = {};

userAdmin.admin?.(); // I am admin

userGuest.admin?.(); // Nothing (no such method)
```

Can also use `[]`

```js
let user1 = {
  firstName: 'John'
};

let user2 = null; // Let's say we can't grant this user access

let key = 'firstName';

alert(user1?.[key]); // John
alert(user2?.[key]); // undefined

alert(user1?.[key]?.something?.not?.existing); // undefined

delete user1?.name; // If user1 exists, delete user1.name
```

### Different Types of Comparisons

> When comparing values of different types, JavaScript first converts them to numbers (number) before determining the size. null/undefined has special rules

```js
alert('2' > 1); // true, the string '2' will be converted to the number 2
alert('01' == 1); // true, the string '01' will be converted to the number 1

alert(true == 1); // true
alert(false == 0); // true
```

**Special rules in js**

```js
// Remember
alert(null == undefined); // true
```

When using mathematical expressions or other comparison methods `< > <= >=`,
`null/undefined` will be converted to a number: `null` is converted to 0, `undefined` is converted to `NaN`

```js
alert(null > 0); // (1) false 0>0
alert(null == 0); // (2) false
alert(null >= 0); // (3) true 0>=0
```

### Object to Primitive Type

```js
let user = {
  name: 'John',
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == 'string' ? `{name: "${this.name}"}` : this.money;
  }
};

// Conversion demonstration:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

**If there is no Symbol.toPrimitive and valueOf, toString will handle all primitive conversions**

### Primitive Type Methods

- “Object wrappers” are different for each primitive type, they are called String, Number, Boolean and Symbol. Therefore, they provide different methods.
- When accessing its properties, a special object containing the string literal is created, and the special object is destroyed after use.
- So primitive types can provide methods, but they are still lightweight.
  The JavaScript engine highly optimizes this process. It may even skip creating extra objects. But it still has to comply with the spec and behave as if it created one.
- All primitive types except null and undefined provide many useful methods.

### Numeric Types

`0.1 + 0.2 !== 0.3`
Because binary cannot accurately store decimals 2
Decimals with 2 as the integer power of the denominator can be accurately represented in the binary digital system, such as 0.5 (1/$2^1$) and 0.25 (1/$2^2$)

```js
alert((0.1).toFixed(20)); // 0.10000000000000000555
```

- parseInt(str, base) parses the string str as an integer in the given base digital system, 2 ≤ base ≤ 36, it reads the digits from the string and then returns the value that can be read before an error occurs.
- isFinite(value) converts its argument to a number, and returns true if it is a regular number, not NaN/Infinity/-Infinity:

  ```js
  alert(isFinite('15')); // true
  alert(isFinite('str')); // false, because it is a special value: NaN
  
