---
slug: hand-write
title: Handwritten questions
date: 2021-02-24T00:00:00.000Z
tags:
  - Front-end knowledge system
keywords:
  - Front-end knowledge system
description: Summary of handwritten js questions for front-end interviews
summary: >-
  Promise is a class that allows you to handle asynchronous operations. You can
  use it to handle asynchronous code and ensure that certain operations are
  performed when the asynchronous operation is complete. Promise has three
  states: pending, completed, and rejected. You can use the then() method to
  handle the completed and rejected states of Promise.


  The new operator is used to create a new object. It uses the constructor to
  create the object and returns the newly created object.


  The instanceof operator is used to check if an object belongs to a certain
  class. It returns a Boolean value, returning true if the object belongs to the
  class, and false otherwise.


  The call() and apply() methods are used to call functions. They both accept a
  list of parameters and pass these parameters to the function. The call()
  method uses the first parameter as the this value of the function, while the
  apply() method uses the first parameter as the this value of the function and
  the second parameter as the list of parameters to the function.


  The bind() method is used to create a new function that will use the specified
  this value when called. It accepts a list of parameters and passes these
  parameters to the new function.
ai_translation: true
---

## Promise

<details>
  <summary>Detailed code</summary>

```js
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

class MyPromise {
  status = PENDING;

  value = null;

  reason = null;

  // Used to store successful and failed callback functions
  onFulfilledCallbacks = [];
  onRejectedCallbacks = [];

  constructor(executor) {
    try {
      executor(this._resolve, this._reject);
    } catch (error) {
      this._reject(error);
    }
  }

  static resolve = p => {
    if (p instanceof MyPromise) {
      return p;
    }

    return new MyPromise(resolve => {
      resolve(p);
    });
  };

  static reject = reason => {
    return new MyPromise((resolve, reject) => {
      reject(reason);
    });
  };

  static all = promises => {
    return new MyPromise((resolve, reject) => {
      let result = [];
      let resolvedCount = 0;

      promises.forEach((promise, index) => {
        promise.then(
          res => {
            result[index] = res;
            resolvedCount++;

            resolvedCount === promises.length && resolve(result);
          },
          error => reject(error)
        );
      });
    });
  };

  static allSettled = promises => {
    const rejectHandler = reason => ({ status: 'rejected', reason });
    const resolveHandler = value => ({ status: 'fulfilled', value });

    const convertedPromises = promises.map(p =>
      Promise.resolve(p).then(resolveHandler, rejectHandler)
    );
    return Promise.all(convertedPromises);
  };

  static race = promises => {
    return new MyPromise((resolve, reject) => {
      promises.forEach((promise, index) => {
        promise.then(
          res => {
            resolve(res);
          },
          error => reject(error)
        );
      });
    });
  };

  _resolve = value => {
    if (this.status === PENDING) {
      this.status = FULFILLED;
      this.value = value;

      while (this.onFulfilledCallbacks.length) {
        this.onFulfilledCallbacks.shift()(value);
      }
    }
  };

  _reject = reason => {
    if (this.status === PENDING) {
      this.status = REJECTED;
      this.reason = reason;

      while (this.onRejectedCallbacks.length) {
        this.onRejectedCallbacks.shift()(reason);
      }
    }
  };

  then = (onFulfilled, onRejected) => {
    // Handle cases where no value is passed
    onFulfilled =
      typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected =
      typeof onRejected === 'function'
        ? onRejected
        : reason => {
            throw reason;
          };

    const thenPromise = new MyPromise((resolve, reject) => {
      if (this.status === FULFILLED) {
        try {
          const fulfilledObj = onFulfilled(this.value);

          resolvePromise(fulfilledObj, resolve, reject);
        } catch (error) {
          reject(error);
        }
      } else if (this.status === REJECTED) {
        onRejected(this.reason);
      } else if (this.status === PENDING) {
        // Handle the case where executor is asynchronous
        this.onFulfilledCallbacks.push(onFulfilled);
        this.onRejectedCallbacks.push(onRejected);
      }
    });

    return thenPromise;
  };
}

function resolvePromise(p, resolve, reject) {
  if (p instanceof MyPromise) {
    p.then(resolve, reject);
  } else {
    resolve(p);
  }
}
```

</details>

## new

Involves knowledge points: prototype chain, **proto**, destructuring assignment, [arguments](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments)

- Create an object
- Get the constructor from arguments and get the prototype through the constructor
- Link the newly created object to the prototype through `__proto__`
- Bind this and execute the constructor

```js
function create() {
  // Create an empty object
  let obj = {};
  // Get the constructor, shift removes the first element and returns the element
  let Con = [].shift.call(arguments);
  // Link to prototype
  obj.__proto__ = Con.prototype;
  // Bind this and execute the constructor
  let result = Con.apply(obj, arguments);
  // Make sure the new output is an object
  return typeof result === 'object' ? result : obj;
}
```

## instance of

Involves knowledge points: prototype chain lookup

```js
function myInstanceOf(obj, cons) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  let objPrototype = obj.__proto__;
  let consPrototype = cons.prototype;

  while (true) {
    if (objPrototype === null) {
      return false;
    }

    if (objPrototype === consPrototype) {
      return true;
    }

    // Look up the prototype chain
    objPrototype = objPrototype.__proto__;
  }
}

console.log(myInstanceOf({}, Object)); // true
```

## call and apply

Involves knowledge points:

- When the first parameter is not passed, it is window in non-strict mode
- Idea: add the function to the new object, execute the function in the context of the new object, and delete it after execution

```js
Function.prototype.myCall = function (...args) {
  const context = args[0] || window;

  // this is the function that calls it
  console.log(this);
  context.excuteFunc = this;

  const result = context.excuteFunc(...args.slice(1));
  delete context.excuteFunc;

  return result;
};

Function.prototype.myApply = function (...args) {
  const context = args[0] || window;

  // this is the function that calls it
  console.log(this);
  context.excuteFunc = this;

  let result;
  if (args[1]) {
    result = context.excuteFunc(...args[1]);
  } else {
    result = context.excuteFunc();
  }
  delete context.excuteFunc;

  return result;
};

const foo = {
  name: 'alan'
};

function sayName(...args) {
  console.log(this.name, args);
}

sayName.myCall(foo, 'args1', 'args2');
sayName.myApply(foo, ['args1', 'args2']);
```

## bind

Involves knowledge:

- Function currying

Return a function that can be called, can be used as a constructor new

```js
Function.prototype.myBind = function (thisArg, ...restArgs) {
  if (typeof this !== 'function') {
    throw new TypeError('not a function');
  }

  const binder = this;

  return function F() {
    console
